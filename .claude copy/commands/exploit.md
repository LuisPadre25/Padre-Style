---
description: System architecture exploitation for maximum performance
allowed-tools: Bash(*), Read, Write, Edit, Grep, Glob, WebSearch, WebFetch
argument-hint: "System or codebase to analyze and optimize"
optimization-level: EXTREME
---

# EXPLOIT MODE: ARCHITECTURE OPTIMIZATION

Systematically analyze $ARGUMENTS to find and exploit architectural opportunities for maximum performance and efficiency.

## EXPLOITATION VECTORS

### DEPENDENCY OPTIMIZATION
- Analyze package.json for redundant dependencies
- Identify heavy libraries that can be replaced with lighter alternatives
- Find tree-shaking opportunities to reduce bundle size
- Use bundle analyzers to identify optimization targets
- Create dependency graphs to understand architecture

### PERFORMANCE EXPLOITATION
- Profile execution time with precision tools
- Exploit browser/runtime optimizations (V8, JIT, etc.)
- Implement multi-layer caching strategies
- Use memory-efficient data structures
- Apply algorithmic optimizations (time/space complexity)

### ARCHITECTURE PATTERNS
- Identify monolithic code that can be modularized
- Find synchronous operations for async conversion
- Locate repeated computations for memoization
- Discover parallelization opportunities
- Implement lazy loading and code splitting

## TECHNICAL EXPLOITATION PATTERNS

### CODE ANALYSIS
```javascript
// Analyze code patterns for optimization opportunities
const analyzeCodebase = async (path) => {
  const patterns = await findPatterns(path);
  const bottlenecks = await profilePerformance(patterns);
  const optimizations = await generateOptimizations(bottlenecks);
  return prioritizeByImpact(optimizations);
};
```

### BUNDLE OPTIMIZATION
- Analyze webpack/vite bundle for optimization
- Implement dynamic imports for code splitting
- Remove unused code through tree shaking
- Optimize asset loading strategies
- Implement progressive web app patterns

### DATABASE OPTIMIZATION
- Identify N+1 query problems
- Optimize database indexes
- Implement query result caching
- Use database-specific optimizations
- Design efficient data access patterns

## EXPLOITATION TOOLS

**PERFORMANCE ANALYSIS:**
```bash
# Bundle size analysis
npm run build -- --analyze

# Performance profiling
lighthouse <url> --output json

# Memory leak detection
node --inspect-brk --expose-gc app.js
```

**CODE QUALITY:**
- Static analysis for code smells
- Cyclomatic complexity measurement
- Dependency vulnerability scanning
- Performance regression testing
- Architecture conformance checking

**OPTIMIZATION STRATEGIES:**
- Micro-optimizations for hot code paths
- Macro-optimizations for architecture
- Progressive enhancement strategies
- Graceful degradation patterns
- Performance budgets enforcement

**FLAGS:**
- --performance: Focus on runtime performance
- --bundle-size: Minimize bundle size aggressively
- --memory: Optimize memory usage
- --startup: Improve application startup time
- --scalability: Optimize for horizontal scaling
- --metrics: Data-driven optimization approach

## TECHNICAL EXCELLENCE
This mode focuses on:
- Evidence-based optimization decisions
- Measurable performance improvements
- Architectural best practices
- Scalable system design
- Maintainable optimization strategies